---
phase: 02-security-access
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - appliances/slm-copilot/appliance.sh
autonomous: true

must_haves:
  truths:
    - "service_bootstrap calls attempt_letsencrypt after nginx is running"
    - "attempt_letsencrypt uses certbot with --webroot mode against /var/www/acme-challenge"
    - "When certbot succeeds, symlinks in /etc/ssl/slm-copilot/ are updated to point to Let's Encrypt certs and nginx is reloaded"
    - "When certbot fails, the appliance logs a warning and continues with the self-signed certificate (no exit, no error)"
    - "attempt_letsencrypt is skipped entirely when ONEAPP_COPILOT_DOMAIN is empty"
    - "A certbot renewal deploy hook is created that reloads nginx on cert renewal"
    - "The complete appliance.sh passes bash -n and shellcheck with no errors"
    - "All 5 Phase 2 success criteria can be verified with the described curl commands"
  artifacts:
    - path: "appliances/slm-copilot/appliance.sh"
      provides: "Complete Phase 2 appliance script with Let's Encrypt automation and graceful fallback"
      contains: "attempt_letsencrypt"
      min_lines: 600
  key_links:
    - from: "service_bootstrap"
      to: "attempt_letsencrypt"
      via: "function call after nginx is started"
      pattern: "attempt_letsencrypt"
    - from: "attempt_letsencrypt"
      to: "certbot"
      via: "certbot certonly --webroot"
      pattern: "certbot certonly"
    - from: "attempt_letsencrypt"
      to: "/etc/ssl/slm-copilot/cert.pem"
      via: "ln -sf to Let's Encrypt fullchain.pem"
      pattern: "ln -sf.*letsencrypt"
    - from: "attempt_letsencrypt"
      to: "nginx -s reload"
      via: "reload after cert swap"
      pattern: "nginx -s reload"
---

<objective>
Implement Let's Encrypt certificate automation with graceful fallback to self-signed. When ONEAPP_COPILOT_DOMAIN is set, the appliance attempts to provision a certificate from Let's Encrypt using certbot's webroot mode. On success, the active certificate symlinks are updated and nginx is reloaded. On failure, the appliance continues with the self-signed certificate and logs a warning.

Purpose: After this plan, the appliance supports both self-signed and Let's Encrypt TLS certificates. This completes SEC-06 and SEC-07, finalizing all Phase 2 requirements. The appliance is fully functional for both private OpenNebula VMs (self-signed) and public-facing deployments (Let's Encrypt).
Output: Extended appliance.sh with attempt_letsencrypt helper and updated service_bootstrap.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-security-access/02-RESEARCH.md
@.planning/phases/02-security-access/02-01-SUMMARY.md
@appliances/slm-copilot/appliance.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement attempt_letsencrypt helper function</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Add the attempt_letsencrypt() helper function in the HELPER section, after the existing generate_nginx_config helper.

```bash
attempt_letsencrypt() {
    local _domain="${ONEAPP_COPILOT_DOMAIN:-}"

    if [ -z "${_domain}" ]; then
        msg info "ONEAPP_COPILOT_DOMAIN not set -- using self-signed certificate"
        return 0
    fi

    msg info "Attempting Let's Encrypt certificate for ${_domain}"

    # Ensure webroot directory structure exists
    mkdir -p /var/www/acme-challenge/.well-known/acme-challenge

    if certbot certonly \
        --non-interactive \
        --agree-tos \
        --register-unsafely-without-email \
        --webroot \
        -w /var/www/acme-challenge \
        -d "${_domain}" 2>&1; then

        # Success: switch active symlinks to Let's Encrypt certs
        ln -sf "/etc/letsencrypt/live/${_domain}/fullchain.pem" "${NGINX_CERT_DIR}/cert.pem"
        ln -sf "/etc/letsencrypt/live/${_domain}/privkey.pem" "${NGINX_CERT_DIR}/key.pem"
        nginx -s reload
        msg info "Let's Encrypt certificate installed for ${_domain}"

        # Set up renewal deploy hook (nginx reload on cert renewal)
        mkdir -p /etc/letsencrypt/renewal-hooks/deploy
        cat > /etc/letsencrypt/renewal-hooks/deploy/nginx-reload.sh <<'HOOK'
#!/bin/bash
nginx -s reload
HOOK
        chmod +x /etc/letsencrypt/renewal-hooks/deploy/nginx-reload.sh
    else
        msg warning "Let's Encrypt failed for ${_domain} -- keeping self-signed certificate"
        msg warning "Ensure: DNS resolves ${_domain} to this VM, port 80 is reachable from internet"
    fi
}
```

**Key design decisions:**
- `--register-unsafely-without-email` -- no email required; appliance VMs are ephemeral
- `--webroot` over `--standalone` -- nginx stays running throughout the process
- Symlink swap instead of file copy -- certbot manages its own files in /etc/letsencrypt; we just point to them
- The function runs in service_bootstrap AFTER nginx is already running with the self-signed cert, so port 80 serves the ACME challenge
- On failure: WARNING (not ERROR), no exit, service continues with self-signed. This is critical for OpenNebula VMs behind NAT/security groups
- The deploy hook ensures nginx picks up renewed certs automatically (certbot timer handles renewal)
- `2>&1` on certbot captures both stdout and stderr for logging

**Ordering constraint:** This function MUST be called after nginx is started because certbot's webroot mode serves the challenge via the running nginx server on port 80.
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Run `grep -c 'attempt_letsencrypt' appliances/slm-copilot/appliance.sh` -- must be >= 2 (definition + call).
Run `grep 'certbot certonly' appliances/slm-copilot/appliance.sh` -- must match.
Run `grep 'ln -sf.*letsencrypt' appliances/slm-copilot/appliance.sh` -- must match symlink swap.
Run `grep 'nginx -s reload' appliances/slm-copilot/appliance.sh` -- must match.
Run `grep 'nginx-reload.sh' appliances/slm-copilot/appliance.sh` -- must match deploy hook.
Run `grep 'msg warning.*Let.*Encrypt.*failed' appliances/slm-copilot/appliance.sh` -- must match fallback warning.
  </verify>
  <done>attempt_letsencrypt() implemented with certbot --webroot mode, graceful fallback to self-signed on failure, symlink swap on success, nginx reload, and deploy hook for automatic renewal. Function returns 0 on both success and failure (never breaks the service).</done>
</task>

<task type="auto">
  <name>Task 2: Wire attempt_letsencrypt into service_bootstrap</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Add the attempt_letsencrypt call to service_bootstrap, AFTER nginx is started and BEFORE the completion message.

The ordering in service_bootstrap must be:
1. systemctl enable + start local-ai (existing)
2. wait_for_localai (existing)
3. systemctl enable + restart nginx (from plan 02-01)
4. **NEW: attempt_letsencrypt** (requires nginx running on port 80 for webroot challenge)
5. Completion message

Add after the `systemctl restart nginx` line:

```bash
    # Phase 2: Attempt Let's Encrypt if domain is configured (SEC-06, SEC-07)
    attempt_letsencrypt
```

**Important:** This call must come AFTER nginx restart because certbot's webroot mode needs nginx serving port 80 to respond to the ACME HTTP-01 challenge.
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Verify ordering in service_bootstrap: `grep -n 'wait_for_localai\|systemctl.*nginx\|attempt_letsencrypt' appliances/slm-copilot/appliance.sh` -- attempt_letsencrypt must have the highest line number.
  </verify>
  <done>attempt_letsencrypt is called in service_bootstrap after nginx is started. Ordering is correct: LocalAI start -> wait for ready -> nginx start -> Let's Encrypt attempt.</done>
</task>

<task type="auto">
  <name>Task 3: Shellcheck compliance and final Phase 2 verification</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Run shellcheck on the complete appliance.sh and fix all warnings. Then verify all Phase 2 requirements are addressed.

**Step 1: Run shellcheck**
```bash
shellcheck -s bash appliances/slm-copilot/appliance.sh
```

Fix any new warnings introduced by the Let's Encrypt code.

**Step 2: Verify all 9 SEC requirements are addressed:**

| Requirement | Code Location | Verification |
|------------|---------------|--------------|
| SEC-01: Self-signed TLS at first boot | generate_selfsigned_cert() in service_configure | openssl req -x509 with VM IP SAN |
| SEC-02: Basic auth on API endpoints | auth_basic in nginx config + generate_htpasswd() | htpasswd -cbB, auth_basic_user_file |
| SEC-03: Auto-generate password | generate_htpasswd() fallback logic | tr -dc from /dev/urandom |
| SEC-04: CORS headers on all responses | add_header with always in nginx config | Three CORS headers at server level |
| SEC-05: OPTIONS returns 204 no auth | if ($request_method = OPTIONS) block | Returns 204 before auth_basic |
| SEC-06: Let's Encrypt when domain set | attempt_letsencrypt() in service_bootstrap | certbot certonly --webroot |
| SEC-07: LE falls back to self-signed | else branch in attempt_letsencrypt() | Warning message, service continues |
| SEC-08: SSE streaming support | 6 directives + gzip off in nginx location | proxy_buffering off, etc. |
| SEC-09: HTTP redirects to HTTPS | port 80 server block in nginx config | return 301 https://$host$request_uri |

**Step 3: Verify all 5 Phase 2 success criteria:**

1. `curl -k https://<vm-ip>/v1/chat/completions` with basic auth returns output; without auth returns 401
   - Verified by: auth_basic + auth_basic_user_file in location /

2. `curl -k https://<vm-ip>/v1/chat/completions` with stream:true delivers SSE incrementally
   - Verified by: 6 anti-buffering directives + ssl_buffer_size 4k + gzip off

3. OPTIONS preflight returns 204 with CORS headers, no auth
   - Verified by: if ($request_method = OPTIONS) block returns 204 before auth_basic

4. Let's Encrypt when domain set; falls back to self-signed on failure
   - Verified by: attempt_letsencrypt() with symlink swap on success, warning on failure

5. HTTP redirect to HTTPS with 301
   - Verified by: port 80 server block with return 301

**Step 4: Verify function count** -- should be 15 total:
5 lifecycle + 10 helpers (validate_config, generate_model_yaml, generate_env_file, generate_systemd_unit, wait_for_localai, smoke_test, generate_selfsigned_cert, generate_htpasswd, generate_nginx_config, attempt_letsencrypt)

**Step 5: Verify line count** -- should be 600+ lines.

**Step 6: No append patterns** -- grep for `>>`, should be 0.
  </action>
  <verify>
Run `shellcheck -s bash appliances/slm-copilot/appliance.sh` -- must exit 0.
Run `bash -n appliances/slm-copilot/appliance.sh` -- must exit 0.
Run `wc -l appliances/slm-copilot/appliance.sh` -- should be 600+ lines.
Run `grep -c '>>' appliances/slm-copilot/appliance.sh` -- should be 0.
Run `grep -cE '^[a-z_]+\(\)' appliances/slm-copilot/appliance.sh` -- should be 15 functions.
Run `grep -c 'SEC-0[1-9]' appliances/slm-copilot/appliance.sh` -- optional, requirement reference comments welcome.
  </verify>
  <done>Complete Phase 2 appliance.sh passes shellcheck and bash -n. All 9 SEC requirements addressed (SEC-01 through SEC-09). All 5 success criteria verifiable. 15 functions total (5 lifecycle + 10 helpers). No append patterns. Ready for Phase 3.</done>
</task>

</tasks>

<verification>
- `shellcheck -s bash appliances/slm-copilot/appliance.sh` exits 0
- `bash -n appliances/slm-copilot/appliance.sh` exits 0
- attempt_letsencrypt(): called in service_bootstrap after nginx start; uses certbot --webroot; swaps symlinks on success; warns on failure; creates renewal deploy hook
- Let's Encrypt is skipped when ONEAPP_COPILOT_DOMAIN is empty (returns 0 immediately)
- certbot failure never causes exit -- service continues with self-signed cert
- All 9 SEC requirements covered: TLS (SEC-01), auth (SEC-02), password gen (SEC-03), CORS (SEC-04), OPTIONS (SEC-05), LE (SEC-06), LE fallback (SEC-07), SSE (SEC-08), redirect (SEC-09)
- No `>>` append patterns anywhere
- Function count: 15 (5 lifecycle + 10 helpers)
</verification>

<success_criteria>
The appliance.sh has complete Let's Encrypt automation with graceful fallback. When ONEAPP_COPILOT_DOMAIN is set, the appliance attempts certbot after nginx starts; on success it swaps the cert symlinks and reloads nginx; on failure it continues with the self-signed certificate. All 9 SEC requirements and all 5 Phase 2 success criteria are satisfied. The script is ready for Phase 3 (OpenNebula Integration).
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-access/02-02-SUMMARY.md`
</output>
