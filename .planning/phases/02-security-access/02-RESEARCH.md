# Phase 2: Security & Access - Research

**Researched:** 2026-02-14
**Domain:** Nginx reverse proxy, TLS termination (self-signed + Let's Encrypt), HTTP basic authentication, CORS headers, SSE streaming proxy, certbot automation
**Confidence:** HIGH

## Summary

Phase 2 adds the security and access layer in front of the LocalAI inference engine from Phase 1. Nginx acts as a reverse proxy on ports 80/443, terminating TLS, enforcing basic authentication, injecting CORS headers, and passing SSE streaming responses without buffering. LocalAI remains on 127.0.0.1:8080, invisible to the network.

The critical findings are: (1) Nginx's default `proxy_buffering on` will silently destroy SSE streaming -- six directives must be set together to ensure token-by-token delivery; (2) CORS preflight OPTIONS requests must bypass basic auth because browsers never send credentials on preflight -- the `if ($request_method = OPTIONS)` block must return 204 before auth is evaluated; (3) Let's Encrypt via certbot requires port 80 reachable from the internet AND valid DNS pointing to the VM IP, which many OpenNebula VMs behind NAT/private networks cannot satisfy -- the fallback to self-signed must be graceful and silent; (4) Nginx refuses to start if certificate files referenced in config don't exist, so self-signed certs must be generated BEFORE the nginx config is written.

**Primary recommendation:** Install nginx + apache2-utils + certbot during `service_install()`. In `service_configure()`, generate self-signed certs with VM IP as SAN, generate htpasswd file, write a single nginx config file covering TLS + auth + CORS + SSE + health bypass + HTTP redirect, then optionally attempt Let's Encrypt if ONEAPP_COPILOT_DOMAIN is set. In `service_bootstrap()`, start nginx after LocalAI is ready.

## Standard Stack

### Core

| Component | Version | Purpose | Why Standard |
|-----------|---------|---------|--------------|
| Nginx | 1.24.x (Ubuntu 24.04 repo) | TLS termination, reverse proxy, basic auth, CORS | Ubuntu LTS default; battle-tested for reverse proxy; proven SSE streaming support; no external repos needed |
| openssl | 3.0.x (Ubuntu 24.04 repo) | Self-signed certificate generation | Generates X.509 certs with SAN for VM IP at boot; ships with Ubuntu |
| apache2-utils | 2.4.x (Ubuntu 24.04 repo) | htpasswd generation for basic auth | Standard tool for Nginx basic auth password files; `htpasswd -nbB` for bcrypt hashing |
| certbot | 2.9.x (Ubuntu 24.04 repo / snap) | Let's Encrypt certificate automation | Standard ACME client; webroot plugin works with running nginx; auto-renewal via systemd timer |

### Supporting

| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| python3-certbot-nginx | 2.x (Ubuntu repo) | Certbot nginx plugin (optional) | NOT recommended -- webroot is safer for appliance automation |
| /dev/urandom + tr | built-in | Random password generation | When ONEAPP_COPILOT_PASSWORD is not set (SEC-03) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Nginx basic auth | LocalAI `--api-keys` flag | LocalAI API key + CORS has a known bug (#4576); no user management; can't exempt health endpoint |
| Nginx basic auth | OAuth2 proxy (oauth2-proxy) | Massive complexity increase; requires identity provider; overkill for single-user appliance |
| Self-signed + Let's Encrypt | Caddy (auto-TLS) | Caddy handles TLS beautifully but adds Go runtime; Nginx already chosen at project start; team has Nginx experience from Flower appliance |
| certbot webroot | certbot standalone | Standalone requires stopping nginx during cert acquisition and renewal; incompatible with always-on appliance |
| certbot webroot | certbot --nginx plugin | Plugin modifies nginx config files directly; unpredictable behavior in appliance context where we generate configs |
| htpasswd (apache2-utils) | openssl passwd | openssl passwd uses older hash algorithms; htpasswd with -B flag uses bcrypt which is stronger |

## Architecture Patterns

### Recommended File Layout

```
/etc/nginx/
  sites-available/
    slm-copilot.conf          # Main config (generated by service_configure)
  sites-enabled/
    slm-copilot.conf -> ../sites-available/slm-copilot.conf
  .htpasswd                   # Basic auth password file (generated)

/etc/ssl/slm-copilot/
  cert.pem                    # TLS certificate (self-signed or Let's Encrypt)
  key.pem                     # TLS private key
  selfsigned-cert.pem         # Self-signed backup (always present)
  selfsigned-key.pem          # Self-signed backup key (always present)

/var/www/acme-challenge/      # Webroot for certbot HTTP-01 challenge
```

### Pattern 1: Self-Signed Certificate Generation with VM IP SAN

**What:** Generate a self-signed certificate at boot with the VM's current IP address as a Subject Alternative Name.
**When to use:** Always -- this is the default TLS mode and the Let's Encrypt fallback.

```bash
generate_selfsigned_cert() {
    local _vm_ip
    _vm_ip=$(hostname -I | awk '{print $1}')
    local _cert_dir="/etc/ssl/slm-copilot"

    mkdir -p "${_cert_dir}"

    openssl req -x509 -nodes -newkey rsa:2048 \
        -keyout "${_cert_dir}/selfsigned-key.pem" \
        -out "${_cert_dir}/selfsigned-cert.pem" \
        -days 3650 \
        -subj "/CN=SLM-Copilot" \
        -addext "subjectAltName=DNS:localhost,IP:127.0.0.1,IP:${_vm_ip}"

    # Symlink as active cert (Let's Encrypt will replace these symlinks)
    ln -sf "${_cert_dir}/selfsigned-cert.pem" "${_cert_dir}/cert.pem"
    ln -sf "${_cert_dir}/selfsigned-key.pem" "${_cert_dir}/key.pem"
}
```

**Key decisions:**
- RSA 2048-bit is sufficient for self-signed (no need for 4096 -- these certs are ephemeral and regenerated every boot)
- 3650-day expiry avoids mid-deployment cert expiration warnings
- SAN includes VM IP so `curl -k https://<vm-ip>/` works without hostname resolution
- Symlink indirection (`cert.pem` -> `selfsigned-cert.pem`) allows Let's Encrypt to swap certs by changing the symlink target, without touching nginx config

### Pattern 2: Basic Auth with Auto-Generated Password

**What:** Generate an htpasswd file for nginx basic auth. If no password provided via context variable, generate a random 16-character alphanumeric password.
**When to use:** Always -- every boot regenerates the htpasswd file.

```bash
generate_htpasswd() {
    local _password="${ONEAPP_COPILOT_PASSWORD:-}"

    if [ -z "${_password}" ]; then
        _password=$(tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 16)
        msg info "No password provided -- auto-generated 16-char password"
    fi

    # -b: batch mode (password on command line)
    # -B: use bcrypt (strongest available)
    # -c: create new file (overwrite for idempotency)
    htpasswd -cbB /etc/nginx/.htpasswd copilot "${_password}"

    # Store password for report file (Phase 3)
    echo "${_password}" > /var/lib/slm-copilot/password
    chmod 0600 /var/lib/slm-copilot/password
}
```

**Key decisions:**
- Username is always `copilot` (single-user appliance, no need for user management)
- `-B` flag for bcrypt -- stronger than default MD5 (APR1)
- `-c` overwrites file (idempotent -- safe on reboot)
- Password stored in a root-only file for the Phase 3 report file to read

### Pattern 3: CORS + Basic Auth + OPTIONS Bypass

**What:** Add CORS headers to all responses, handle OPTIONS preflight without authentication, require auth for everything else except /health and /readyz.
**When to use:** Always -- this is the complete nginx location block pattern.

```nginx
# CORS headers on ALL responses (including error responses)
add_header Access-Control-Allow-Origin "*" always;
add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;

# Handle OPTIONS preflight (no auth, no proxy)
if ($request_method = OPTIONS) {
    add_header Access-Control-Allow-Origin "*" always;
    add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
    add_header Access-Control-Max-Age 86400 always;
    add_header Content-Length 0 always;
    return 204;
}

# Basic auth for non-OPTIONS requests
auth_basic "SLM-Copilot API";
auth_basic_user_file /etc/nginx/.htpasswd;
```

**Why duplicate headers in the `if` block:** Nginx's `add_header` does not inherit into `if` blocks. Headers declared outside the `if` are NOT applied when the `if` matches. This is a well-documented nginx behavior and a very common source of bugs. The headers must be redeclared inside the `if` block.

**Why `always`:** Without `always`, `add_header` only applies to status codes 200, 201, 204, 206, 301-304, 307, 308. Error responses (401, 500) would lack CORS headers, causing browsers to silently reject the error response -- the developer would see a generic CORS error instead of the actual backend error message.

**Why `*` for Allow-Origin:** This appliance is designed for single-developer use with VS Code/Cline. Cline sends requests from a VS Code webview context. Restricting origins would break legitimate use. The basic auth password IS the access control. CORS wildcard is acceptable here.

### Pattern 4: SSE Streaming Through Nginx Proxy

**What:** Configure nginx to pass SSE responses from LocalAI without buffering, ensuring token-by-token delivery.
**When to use:** Always -- the main proxy location block.

```nginx
location / {
    proxy_pass http://127.0.0.1:8080;
    proxy_http_version 1.1;

    # SSE streaming -- ALL SIX directives are required
    proxy_buffering off;              # Don't buffer upstream response
    proxy_cache off;                  # Don't cache streaming responses
    proxy_set_header Connection '';   # Clear Connection header for HTTP/1.1
    proxy_set_header X-Accel-Buffering no;  # Tell nginx to disable accel buffering
    chunked_transfer_encoding off;    # Disable chunked encoding for SSE
    proxy_read_timeout 600s;          # 10-minute timeout for long CPU inference
}
```

**Why 600s timeout:** CPU inference of a 2000-token response at 3-5 tok/s takes 400-660 seconds. The default nginx `proxy_read_timeout` of 60s would kill long inference requests mid-stream. 600s (10 minutes) provides sufficient headroom.

**Why all six directives:** Each controls a different buffering layer. Missing ANY one of them can cause token buffering:
- `proxy_buffering off` -- main response buffering
- `proxy_cache off` -- nginx cache layer
- `Connection ''` -- prevents HTTP/1.0 connection closure
- `X-Accel-Buffering no` -- nginx acceleration layer
- `chunked_transfer_encoding off` -- prevents chunk reassembly
- `proxy_read_timeout 600s` -- prevents premature connection termination

### Pattern 5: Health Endpoint Without Auth

**What:** Exempt /health and /readyz from basic auth so monitoring tools can probe the appliance.
**When to use:** Always.

```nginx
location = /readyz {
    auth_basic off;
    proxy_pass http://127.0.0.1:8080/readyz;
}

location = /health {
    auth_basic off;
    return 200 'ok\n';
    add_header Content-Type text/plain;
}
```

**Key decision:** The /readyz endpoint proxies to LocalAI (real health check -- returns 200 only when model is loaded). The /health endpoint is a simple nginx-level check (is nginx itself alive). Both bypass auth.

### Pattern 6: Let's Encrypt with Graceful Fallback

**What:** Attempt certbot when ONEAPP_COPILOT_DOMAIN is set. If it fails, keep using self-signed certs. Never break the service.
**When to use:** Only when ONEAPP_COPILOT_DOMAIN is set.

```bash
attempt_letsencrypt() {
    local _domain="${ONEAPP_COPILOT_DOMAIN}"
    local _cert_dir="/etc/ssl/slm-copilot"

    # Pre-flight checks
    if [ -z "${_domain}" ]; then
        msg info "ONEAPP_COPILOT_DOMAIN not set -- skipping Let's Encrypt"
        return 0
    fi

    # Attempt certbot with webroot (nginx must already be running with self-signed)
    if certbot certonly \
        --non-interactive \
        --agree-tos \
        --register-unsafely-without-email \
        --webroot \
        -w /var/www/acme-challenge \
        -d "${_domain}" 2>&1; then

        # Success -- point symlinks to Let's Encrypt certs
        ln -sf "/etc/letsencrypt/live/${_domain}/fullchain.pem" "${_cert_dir}/cert.pem"
        ln -sf "/etc/letsencrypt/live/${_domain}/privkey.pem" "${_cert_dir}/key.pem"
        nginx -s reload
        msg info "Let's Encrypt certificate installed for ${_domain}"
    else
        msg warning "Let's Encrypt failed for ${_domain} -- keeping self-signed certificate"
        msg warning "Common causes: DNS not resolving, port 80 not reachable, rate limit"
    fi
}
```

**Key decisions:**
- `--register-unsafely-without-email` -- no email required; appliance is ephemeral
- `--webroot` over `--standalone` -- nginx stays running throughout
- Symlink swap instead of file copy -- certbot manages its own files; we just point to them
- Let's Encrypt attempt happens in `service_bootstrap()` AFTER nginx is already running with self-signed, not in `service_configure()`
- Failure is a warning, never an error -- the service continues with self-signed

### Pattern 7: HTTP-to-HTTPS Redirect

**What:** Port 80 redirects all requests to HTTPS, except the ACME challenge path (needed for certbot webroot).
**When to use:** Always.

```nginx
server {
    listen 80 default_server;
    server_name _;

    # Let's Encrypt HTTP-01 challenge (must work without redirect)
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/acme-challenge;
    }

    # Everything else -> HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}
```

**Why `^~` for acme-challenge:** The `^~` modifier ensures this location takes priority over regex locations, preventing the redirect from intercepting ACME challenges.

### Anti-Patterns to Avoid

- **Using `limit_except OPTIONS` for auth bypass:** While technically correct, it is harder to read and maintain than the `if ($request_method = OPTIONS) { return 204; }` pattern. The `if` + `return` pattern is one of the safe uses of `if` in nginx (no `proxy_pass` inside the `if`).
- **Using `proxy_buffering off` globally:** Apply it only to the reverse proxy location, not to static file serving or ACME challenge locations.
- **Generating certs in `service_install()`:** The VM IP is unknown at Packer build time. Cert generation must happen in `service_configure()` when the VM has its actual IP.
- **Using certbot `--nginx` plugin:** The plugin modifies nginx config files directly. We generate our own config -- the plugin would fight with our generation logic and create unpredictable states.
- **Omitting `always` on `add_header`:** Headers without `always` disappear on 401/500 responses, breaking CORS error handling in browsers.
- **Storing password in nginx config comments:** Anyone who can read nginx config can see the password. Store it in a separate root-only file.
- **Using `gzip on` for SSE endpoints:** Gzip compresses and buffers output, destroying streaming. Either disable gzip globally or ensure SSE responses are excluded.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Password hashing | Custom hash function in bash | `htpasswd -B` from apache2-utils | Bcrypt is the standard; hand-rolled hashing will be weak |
| Random password | `$RANDOM` or `date +%s` | `tr -dc 'A-Za-z0-9' < /dev/urandom \| head -c 16` | /dev/urandom is cryptographically secure; $RANDOM is predictable |
| Certificate generation | Manual openssl multi-step process | Single `openssl req -x509` with `-addext` | One command, no intermediate CSR, no cleanup needed |
| ACME challenges | Custom HTTP server for domain validation | certbot with `--webroot` | Battle-tested, handles edge cases, auto-renewal timers |
| CORS handling | Custom Lua or application-level CORS | Nginx `add_header` directives | Nginx handles this at the proxy layer; no application changes needed |
| SSE buffering control | Custom streaming proxy | Nginx proxy with 6 anti-buffering directives | Nginx is purpose-built for this; no custom code needed |

## Common Pitfalls

### Pitfall 1: Nginx Won't Start Without Certificate Files

**What goes wrong:** Nginx config references `ssl_certificate` and `ssl_certificate_key` paths that don't exist yet. Nginx refuses to start at all -- not even the HTTP server block works.
**Why it happens:** Unlike Apache, nginx validates ALL referenced file paths at startup across ALL server blocks. Even if the HTTP (port 80) block is fine, a broken HTTPS block kills the entire nginx process.
**How to avoid:** Always generate self-signed certificates BEFORE writing the nginx config. In `service_configure()`, the order is: (1) generate certs, (2) generate htpasswd, (3) write nginx config, (4) `nginx -t` to validate.
**Warning signs:** `systemctl status nginx` shows "nginx: [emerg] cannot load certificate". No HTTP or HTTPS serves.

### Pitfall 2: CORS Headers Missing on 401 Error Responses

**What goes wrong:** Browser sends request without credentials (or wrong credentials). Nginx returns 401. But the 401 response has no CORS headers (because `add_header` without `always` only applies to success codes). Browser shows a CORS error instead of the 401, confusing the developer.
**Why it happens:** Default `add_header` behavior in nginx omits headers from error responses.
**How to avoid:** Use `always` on every `add_header` directive: `add_header Access-Control-Allow-Origin "*" always;`
**Warning signs:** Browser console shows "CORS error" but the real problem is authentication failure.

### Pitfall 3: CORS Headers Duplicated by Upstream

**What goes wrong:** LocalAI also sets CORS headers (if `--cors` flag is enabled). Nginx adds its own. Browser receives duplicate `Access-Control-Allow-Origin` headers and rejects the response.
**Why it happens:** LocalAI has `--cors` and `--cors-allow-origins` flags. If enabled alongside nginx CORS headers, both layers emit headers.
**How to avoid:** Do NOT enable CORS in LocalAI (`--cors` should not be set). Handle CORS exclusively in nginx. This is already the case in our Phase 1 config (no `--cors` flag in the systemd unit).
**Warning signs:** Browser shows "The 'Access-Control-Allow-Origin' header contains multiple values".

### Pitfall 4: SSE Streaming Works on HTTP But Not Through HTTPS

**What goes wrong:** Streaming works fine when tested against LocalAI directly (`curl http://127.0.0.1:8080`), but through nginx HTTPS proxy, tokens arrive in batches or all at once.
**Why it happens:** TLS adds a buffering layer. SSL buffer size defaults can accumulate small SSE chunks before flushing. Additionally, `gzip` (often enabled by default in Ubuntu's nginx.conf) compresses and buffers output.
**How to avoid:** Add `ssl_buffer_size 4k;` to reduce TLS buffer (default is 16k). Ensure `gzip off;` is set in the streaming location, or set `gzip_types` to exclude `text/event-stream`.
**Warning signs:** Works with `curl http://localhost:8080` (direct), fails with `curl -k https://vm-ip/` (through proxy). Tokens arrive in bursts every few seconds instead of one by one.

### Pitfall 5: Let's Encrypt Fails in OpenNebula VM Networking

**What goes wrong:** certbot fails with "Connection refused" or "DNS not resolving" even though the domain is configured and the VM is running.
**Why it happens:** OpenNebula VMs in many deployments use:
  - **NAT networking:** VM has a private IP (10.x, 172.x, 192.168.x). Port 80 is not forwarded from the public IP.
  - **Security groups:** Port 80 may be blocked by OpenNebula security group rules.
  - **Floating IPs:** The VM's `hostname -I` returns the private IP, but the domain points to a floating public IP.
  - **Edge clusters:** VMs in edge providers (AWS, GCP, DO) have port forwarding from host to VM, but the ACME challenge may not traverse this correctly.
**How to avoid:** Let's Encrypt must be optional with graceful fallback. Document the requirements: "ONEAPP_COPILOT_DOMAIN requires a public FQDN with DNS A/AAAA record pointing to the VM's public IP, and port 80 reachable from the internet." The appliance must work perfectly with just self-signed certs.
**Warning signs:** certbot logs show "Could not reach http://<domain>/.well-known/acme-challenge/...". Often works in development but fails in production OpenNebula deployments.

### Pitfall 6: Password Visible in OpenNebula Sunstone

**What goes wrong:** The auto-generated or user-provided password is stored in the ONEAPP_COPILOT_PASSWORD context variable, which is visible to anyone with read access to the VM in Sunstone.
**Why it happens:** OpenNebula context variables are stored in the VM template and are visible in the Sunstone UI. There is no "secret" variable type in OpenNebula contextualization.
**How to avoid:** Document this as a known limitation. The password protects the API from casual network access, not from the VM's cloud administrator. For production deployments with stronger security requirements, users should SSH in and change the password manually. This is acceptable for an MVP appliance.
**Warning signs:** Not a runtime failure -- this is a security posture documentation issue.

## Code Examples

### Complete Nginx Configuration (single file)

```nginx
# /etc/nginx/sites-available/slm-copilot.conf
# Generated by SLM-Copilot appliance at $(date -u)

# --- HTTP server (port 80): redirect to HTTPS + ACME challenge ---
server {
    listen 80 default_server;
    server_name _;

    # Let's Encrypt HTTP-01 challenge
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/acme-challenge;
    }

    # Redirect everything else to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

# --- HTTPS server (port 443): TLS + auth + proxy ---
server {
    listen 443 ssl default_server;
    server_name _;

    # TLS configuration
    ssl_certificate     /etc/ssl/slm-copilot/cert.pem;
    ssl_certificate_key /etc/ssl/slm-copilot/key.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ssl_buffer_size     4k;    # Smaller TLS buffer for SSE streaming

    # CORS headers on ALL responses (including errors)
    add_header Access-Control-Allow-Origin "*" always;
    add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;

    # --- Health check endpoints (no auth) ---
    location = /readyz {
        auth_basic off;
        proxy_pass http://127.0.0.1:8080/readyz;
    }

    location = /health {
        auth_basic off;
        return 200 'ok\n';
        add_header Content-Type text/plain always;
    }

    # --- Main API proxy ---
    location / {
        # Handle OPTIONS preflight (no auth, no proxy)
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin "*" always;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
            add_header Access-Control-Max-Age 86400 always;
            add_header Content-Length 0 always;
            return 204;
        }

        # Basic authentication
        auth_basic "SLM-Copilot API";
        auth_basic_user_file /etc/nginx/.htpasswd;

        # Reverse proxy to LocalAI
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # SSE streaming (ALL required)
        proxy_buffering off;
        proxy_cache off;
        proxy_set_header Connection '';
        proxy_set_header X-Accel-Buffering no;
        chunked_transfer_encoding off;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;
    }
}
```

### Self-Signed Certificate Generation

```bash
generate_selfsigned_cert() {
    local _vm_ip
    _vm_ip=$(hostname -I | awk '{print $1}')
    local _cert_dir="/etc/ssl/slm-copilot"

    mkdir -p "${_cert_dir}"

    openssl req -x509 -nodes -newkey rsa:2048 \
        -keyout "${_cert_dir}/selfsigned-key.pem" \
        -out "${_cert_dir}/selfsigned-cert.pem" \
        -days 3650 \
        -subj "/CN=SLM-Copilot" \
        -addext "subjectAltName=DNS:localhost,IP:127.0.0.1,IP:${_vm_ip}"

    chmod 0600 "${_cert_dir}/selfsigned-key.pem"
    chmod 0644 "${_cert_dir}/selfsigned-cert.pem"

    # Active cert symlinks (Let's Encrypt replaces these)
    ln -sf "${_cert_dir}/selfsigned-cert.pem" "${_cert_dir}/cert.pem"
    ln -sf "${_cert_dir}/selfsigned-key.pem" "${_cert_dir}/key.pem"

    msg info "Self-signed certificate generated for ${_vm_ip}"
}
```

### Password and htpasswd Generation

```bash
generate_htpasswd() {
    local _password="${ONEAPP_COPILOT_PASSWORD:-}"

    if [ -z "${_password}" ]; then
        _password=$(tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 16)
        msg info "Auto-generated API password (no ONEAPP_COPILOT_PASSWORD set)"
    fi

    htpasswd -cbB /etc/nginx/.htpasswd copilot "${_password}"
    chmod 0640 /etc/nginx/.htpasswd

    # Persist for report file (Phase 3)
    mkdir -p /var/lib/slm-copilot
    echo "${_password}" > /var/lib/slm-copilot/password
    chmod 0600 /var/lib/slm-copilot/password

    msg info "htpasswd written to /etc/nginx/.htpasswd (user: copilot)"
}
```

### Let's Encrypt Attempt with Fallback

```bash
attempt_letsencrypt() {
    local _domain="${ONEAPP_COPILOT_DOMAIN:-}"
    local _cert_dir="/etc/ssl/slm-copilot"

    if [ -z "${_domain}" ]; then
        msg info "ONEAPP_COPILOT_DOMAIN not set -- using self-signed certificate"
        return 0
    fi

    msg info "Attempting Let's Encrypt certificate for ${_domain}"

    # Ensure webroot directory exists
    mkdir -p /var/www/acme-challenge/.well-known/acme-challenge

    if certbot certonly \
        --non-interactive \
        --agree-tos \
        --register-unsafely-without-email \
        --webroot \
        -w /var/www/acme-challenge \
        -d "${_domain}" 2>&1; then

        # Switch active symlinks to Let's Encrypt certs
        ln -sf "/etc/letsencrypt/live/${_domain}/fullchain.pem" "${_cert_dir}/cert.pem"
        ln -sf "/etc/letsencrypt/live/${_domain}/privkey.pem" "${_cert_dir}/key.pem"
        nginx -s reload
        msg info "Let's Encrypt certificate installed for ${_domain}"

        # Set up renewal hook
        cat > /etc/letsencrypt/renewal-hooks/deploy/nginx-reload.sh <<'HOOK'
#!/bin/bash
nginx -s reload
HOOK
        chmod +x /etc/letsencrypt/renewal-hooks/deploy/nginx-reload.sh
    else
        msg warning "Let's Encrypt failed for ${_domain} -- keeping self-signed certificate"
        msg warning "Ensure: DNS resolves ${_domain} to this VM, port 80 is reachable from internet"
    fi
}
```

### ONE_SERVICE_PARAMS Additions (Phase 2 context variables)

```bash
ONE_SERVICE_PARAMS=(
    # Phase 1 params (existing)
    'ONEAPP_COPILOT_CONTEXT_SIZE'  'configure' 'Model context window in tokens'              '32768'
    'ONEAPP_COPILOT_THREADS'       'configure' 'CPU threads for inference (0=auto-detect)'   '0'

    # Phase 2 params (new)
    'ONEAPP_COPILOT_PASSWORD'      'configure' 'API password (auto-generated if empty)'      ''
    'ONEAPP_COPILOT_DOMAIN'        'configure' 'FQDN for Let'\''s Encrypt certificate'       ''
)
```

### Default Variable Assignments

```bash
ONEAPP_COPILOT_PASSWORD="${ONEAPP_COPILOT_PASSWORD:-}"
ONEAPP_COPILOT_DOMAIN="${ONEAPP_COPILOT_DOMAIN:-}"
```

## Lifecycle Integration

### Where Phase 2 code goes in appliance.sh

```
service_install()
  ... existing Phase 1 steps ...
  NEW: apt-get install nginx apache2-utils certbot    (SEC-01, SEC-02, SEC-06)
  NEW: mkdir -p /var/www/acme-challenge               (SEC-06)
  NEW: rm -f /etc/nginx/sites-enabled/default         (remove default site)

service_configure()
  ... existing Phase 1 steps ...
  NEW: generate_selfsigned_cert                        (SEC-01)
  NEW: generate_htpasswd                               (SEC-02, SEC-03)
  NEW: generate_nginx_config                           (SEC-04, SEC-05, SEC-08, SEC-09)
  NEW: nginx -t                                        (validate config)

service_bootstrap()
  ... existing Phase 1 steps (start LocalAI, wait for readyz) ...
  NEW: systemctl enable nginx                          (SEC-01)
  NEW: systemctl restart nginx                         (SEC-01)
  NEW: attempt_letsencrypt                             (SEC-06, SEC-07)
```

### Ordering Constraints

1. Self-signed certs MUST be generated before nginx config is written (nginx validates cert paths at startup)
2. htpasswd MUST be generated before nginx config is written (nginx validates htpasswd path at startup)
3. Nginx config MUST be validated with `nginx -t` before starting nginx
4. LocalAI MUST be running before nginx starts proxying (otherwise health check proxy fails)
5. Nginx MUST be running before certbot attempts webroot challenge (certbot needs port 80 served)
6. Let's Encrypt happens in bootstrap, not configure (needs nginx running)

## Context Variable Design

| Variable | Default | Validation | Description |
|----------|---------|------------|-------------|
| `ONEAPP_COPILOT_PASSWORD` | (empty = auto-generate) | Non-empty string if provided | API password for basic auth. If empty, a random 16-char alphanumeric password is generated. Username is always `copilot`. |
| `ONEAPP_COPILOT_DOMAIN` | (empty = skip LE) | Valid FQDN (contains dot, no spaces) | Domain name for Let's Encrypt. If empty, self-signed cert only. Setting this triggers certbot attempt. |

**Naming convention:** Follows `ONEAPP_COPILOT_*` prefix established in Phase 1.

## Requirement-to-Implementation Mapping

| Requirement | Implementation | Key Config/Code |
|-------------|---------------|-----------------|
| SEC-01: Self-signed TLS at first boot | `generate_selfsigned_cert()` in `service_configure` | `openssl req -x509 -addext subjectAltName=IP:${vm_ip}` |
| SEC-02: Basic auth on API endpoints | `auth_basic` + `auth_basic_user_file` in nginx location | `htpasswd -cbB /etc/nginx/.htpasswd copilot "${password}"` |
| SEC-03: Auto-generate password if not provided | `tr -dc 'A-Za-z0-9' < /dev/urandom \| head -c 16` | Check `ONEAPP_COPILOT_PASSWORD`, generate if empty |
| SEC-04: CORS headers on all responses | `add_header Access-Control-Allow-* always` | `always` modifier ensures error responses get CORS too |
| SEC-05: OPTIONS preflight returns 204 no auth | `if ($request_method = OPTIONS) { return 204; }` | OPTIONS block before auth_basic in location / |
| SEC-06: Let's Encrypt when domain set | `attempt_letsencrypt()` in `service_bootstrap` | `certbot certonly --webroot -d ${domain}` |
| SEC-07: LE falls back to self-signed | `attempt_letsencrypt()` returns on failure, symlinks unchanged | Warning message logged, service continues |
| SEC-08: SSE streaming support | 6 anti-buffering directives in proxy location | `proxy_buffering off`, `proxy_cache off`, `Connection ''`, etc. |
| SEC-09: HTTP redirects to HTTPS | Port 80 server block with `return 301 https://...` | ACME challenge path excluded from redirect |

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `ssl_protocols TLSv1 TLSv1.1 TLSv1.2` | `ssl_protocols TLSv1.2 TLSv1.3` only | 2020+ (TLS 1.0/1.1 deprecated) | Always use TLSv1.2+ only; older protocols have known vulnerabilities |
| `add_header` without `always` | `add_header ... always` | nginx 1.7.5+ (2014) | `always` is required for error responses; widely adopted since 2020+ |
| certbot `--standalone` for initial cert | certbot `--webroot` | Standard practice | Webroot doesn't require stopping the web server; better for always-on services |
| apache2-utils MD5 (APR1) passwords | `htpasswd -B` (bcrypt) | Available since apache2-utils 2.4 | Bcrypt is significantly more resistant to brute-force; default APR1 is weak by modern standards |
| `proxy_read_timeout 60s` default | 600s for LLM inference | 2024+ (LLM proxy patterns) | CPU inference can take minutes for long responses; default 60s kills requests |

## Open Questions

1. **`ssl_buffer_size` optimal value for SSE**
   - What we know: Default is 16k. Smaller values (1k-4k) flush TLS records more frequently, reducing streaming latency.
   - What's unclear: Whether 4k is optimal or whether 1k would be better for single-token SSE chunks (~50-100 bytes each).
   - Recommendation: Start with 4k. If SSE still shows micro-batching through TLS, reduce to 1k. Test with `curl -Nsk`.

2. **certbot snap vs apt package on Ubuntu 24.04**
   - What we know: certbot.eff.org recommends snap. Ubuntu 24.04 ships certbot in apt repos (python3-certbot).
   - What's unclear: Whether the apt version in Ubuntu 24.04 is recent enough for all features we need.
   - Recommendation: Use apt (`apt-get install certbot`). Snap adds snapd dependency and complexity. The apt version (2.9.x) is sufficient for `certonly --webroot`. Keep it simple.

3. **Nginx default site conflict**
   - What we know: Ubuntu's nginx package ships with `/etc/nginx/sites-enabled/default` which listens on port 80.
   - What's unclear: Whether our config will conflict if we don't remove the default site.
   - Recommendation: Remove default site in `service_install()`: `rm -f /etc/nginx/sites-enabled/default`. Safe and idempotent.

4. **`gzip` interaction with SSE**
   - What we know: Ubuntu's default nginx.conf may enable `gzip on`. Gzip compresses and buffers output, potentially breaking SSE.
   - What's unclear: Whether LocalAI's SSE responses have `Content-Type: text/event-stream` which may or may not be in the default `gzip_types`.
   - Recommendation: Add `gzip off;` inside the main location block to be safe. This only affects the API proxy, not static files. Alternatively, ensure `text/event-stream` is not in `gzip_types`.

## Sources

### Primary (HIGH confidence)

- [Nginx HTTP Proxy Module](https://nginx.org/en/docs/http/ngx_http_proxy_module.html) -- `proxy_buffering`, `proxy_cache`, `proxy_read_timeout`, `proxy_http_version` reference
- [Nginx HTTP Auth Basic Module](https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html) -- `auth_basic`, `auth_basic_user_file` reference
- [Nginx HTTP SSL Module](https://nginx.org/en/docs/http/ngx_http_ssl_module.html) -- `ssl_certificate`, `ssl_protocols`, `ssl_buffer_size` reference
- [NGINX CORS Configuration Complete Guide (2026)](https://www.getpagespeed.com/server-setup/nginx/nginx-cors) -- `always` modifier requirement, `if` block header inheritance
- [NGINX Basic Auth with htpasswd (2026)](https://www.getpagespeed.com/server-setup/nginx/nginx-basic-auth-htpasswd) -- apache2-utils installation, bcrypt with -B flag
- [DigitalOcean: Nginx Optimization for SSE](https://www.digitalocean.com/community/questions/nginx-optimization-for-server-sent-events-sse) -- comprehensive proxy directives for SSE
- [Certbot User Guide](https://eff-certbot.readthedocs.io/en/stable/using.html) -- `--non-interactive`, `--webroot`, `--deploy-hook`, renewal
- [DigitalOcean: Self-Signed SSL for Nginx on Ubuntu](https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu) -- openssl one-liner with SAN
- [CORS with Basic Auth nginx gist](https://gist.github.com/stokito/fc5be8ac74be46f8d5daaa41e8279d58) -- complete working example of OPTIONS bypass with auth
- [CORS under basic auth gist](https://gist.github.com/x-yuri/102dac7a1022a43cfd7346268fe1c47a) -- `limit_except OPTIONS` pattern
- [Flower SuperLink appliance](file:///home/pablo/flower-opennebula/appliances/flower_service/appliance-superlink.sh) -- TLS cert generation pattern, one-apps lifecycle

### Secondary (MEDIUM confidence)

- [SSE troubleshooting in multi-service architecture](https://medium.com/@wang645788/troubleshooting-server-sent-events-sse-in-a-multi-service-architecture-5084ce155ea0) -- `proxy_http_version 1.1` requirement
- [Surviving SSE Behind Nginx Proxy Manager](https://medium.com/@dsherwin/surviving-sse-behind-nginx-proxy-manager-npm-a-real-world-deep-dive-69c5a6e8b8e5) -- real-world SSE debugging
- [Let's Encrypt chicken-and-egg](https://medium.com/@arthur.lewis/solving-the-chicken-and-egg-problem-setting-up-a-lets-encrypt-ssl-certificate-for-nginx-c1a194f881bd) -- self-signed bootstrap pattern
- [Nginx AI Proxy Blog](https://blog.nginx.org/blog/using-nginx-as-an-ai-proxy) -- SSE streaming config for AI models
- [Atlantic.net: Basic HTTP Authentication with Nginx on Ubuntu 24.04](https://www.atlantic.net/dedicated-server-hosting/configuring-basic-http-authentication-with-nginx-on-ubuntu-24-04/) -- Ubuntu 24.04 specific instructions
- [OpenNebula NAT Networking Forum](https://forum.opennebula.io/t/configuring-a-virtual-network-with-nat/8981) -- NAT and port forwarding in OpenNebula VMs

### Tertiary (LOW confidence)

- `ssl_buffer_size` optimal value for SSE tokens -- 4k is a common recommendation but not empirically verified for single-token LLM SSE chunks
- certbot apt vs snap on Ubuntu 24.04 -- both should work; snap is officially recommended but apt is simpler for appliance context

## Metadata

**Confidence breakdown:**
- Nginx reverse proxy config: HIGH -- standard patterns, verified from official docs and community gists
- Self-signed cert generation: HIGH -- proven pattern from Flower appliance, standard openssl usage
- Basic auth: HIGH -- standard htpasswd + nginx auth_basic, verified on Ubuntu 24.04
- CORS handling: HIGH -- well-documented nginx behavior, `always` modifier verified
- SSE streaming: HIGH -- multiple sources agree on the same 6 directives, verified in production
- Let's Encrypt: MEDIUM -- certbot webroot is standard, but OpenNebula VM networking edge cases add uncertainty
- Password generation: HIGH -- /dev/urandom is cryptographically secure, standard pattern

**Research date:** 2026-02-14
**Valid until:** 2026-03-14 (nginx 1.24.x is stable LTS; certbot 2.9.x is stable)
