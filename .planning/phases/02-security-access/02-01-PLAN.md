---
phase: 02-security-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - appliances/slm-copilot/appliance.sh
autonomous: true

must_haves:
  truths:
    - "service_install installs nginx, apache2-utils, and certbot via apt-get"
    - "service_install removes the default nginx site and creates /var/www/acme-challenge"
    - "service_configure generates a self-signed certificate with the VM IP as a SAN before writing nginx config"
    - "service_configure generates an htpasswd file with bcrypt hashing (htpasswd -cbB) before writing nginx config"
    - "service_configure generates the complete nginx config with TLS, basic auth, CORS, OPTIONS bypass, SSE streaming, health bypass, and HTTP redirect"
    - "service_configure validates nginx config with nginx -t before proceeding"
    - "service_bootstrap starts nginx after LocalAI is ready"
    - "Nginx proxy passes requests to http://127.0.0.1:8080 with all 6 SSE anti-buffering directives"
    - "Health endpoints /readyz and /health bypass basic auth"
    - "OPTIONS requests return 204 with CORS headers without requiring authentication"
    - "HTTP port 80 redirects to HTTPS port 443 (except ACME challenge path)"
    - "CORS headers include the always modifier on all add_header directives"
    - "Password is auto-generated (16-char alphanumeric from /dev/urandom) when ONEAPP_COPILOT_PASSWORD is empty"
    - "ONEAPP_COPILOT_PASSWORD and ONEAPP_COPILOT_DOMAIN are added to ONE_SERVICE_PARAMS"
  artifacts:
    - path: "appliances/slm-copilot/appliance.sh"
      provides: "Appliance script extended with complete Nginx reverse proxy, TLS, auth, CORS, SSE streaming"
      contains: "generate_nginx_config"
      min_lines: 550
  key_links:
    - from: "service_install"
      to: "nginx"
      via: "apt-get install nginx apache2-utils certbot"
      pattern: "apt-get install.*nginx.*apache2-utils.*certbot"
    - from: "service_configure"
      to: "/etc/ssl/slm-copilot/cert.pem"
      via: "generate_selfsigned_cert helper with openssl"
      pattern: "openssl req.*-x509"
    - from: "service_configure"
      to: "/etc/nginx/.htpasswd"
      via: "generate_htpasswd helper"
      pattern: "htpasswd.*-cbB"
    - from: "service_configure"
      to: "/etc/nginx/sites-available/slm-copilot.conf"
      via: "generate_nginx_config helper with heredoc"
      pattern: "cat.*>.*slm-copilot.conf"
    - from: "service_bootstrap"
      to: "nginx"
      via: "systemctl enable + restart"
      pattern: "systemctl.*nginx"
---

<objective>
Install Nginx and all security dependencies, implement self-signed TLS certificate generation, basic authentication with password auto-generation, CORS headers, OPTIONS preflight bypass, SSE streaming proxy configuration, health endpoint bypass, and HTTP-to-HTTPS redirect. Add the Phase 2 context variables (ONEAPP_COPILOT_PASSWORD, ONEAPP_COPILOT_DOMAIN) to the appliance parameter array.

Purpose: After this plan, the appliance has a fully functional Nginx reverse proxy that terminates TLS with a self-signed certificate, enforces basic auth, handles CORS, streams SSE tokens without buffering, and redirects HTTP to HTTPS. This covers SEC-01 through SEC-05, SEC-08, and SEC-09.
Output: Extended appliance.sh with Nginx integration across all three lifecycle stages and five new helper functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-security-access/02-RESEARCH.md
@appliances/slm-copilot/appliance.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend service_install with Nginx, apache2-utils, and certbot installation</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Extend service_install() by adding Nginx and security package installation AFTER the existing jq installation step.

**Add after the existing `apt-get install -y -qq jq >/dev/null` line:**

```bash
# Phase 2: Install Nginx, htpasswd tool, and certbot
apt-get install -y -qq nginx apache2-utils certbot >/dev/null

# Remove default nginx site (conflicts with our config)
rm -f /etc/nginx/sites-enabled/default

# Create ACME challenge directory for certbot webroot
mkdir -p /var/www/acme-challenge
```

**Important notes:**
- Install happens at Packer build time, so all packages are baked into the image.
- Nginx is installed but NOT started or enabled in service_install -- that happens in service_bootstrap.
- The default site removal is idempotent (`rm -f` never fails).
- The ACME challenge directory must exist before nginx starts (the config references it).

Do NOT install python3-certbot-nginx -- we use `--webroot` mode, not the nginx plugin.

Also add a new constant to the constants section:
```bash
readonly NGINX_CONF="/etc/nginx/sites-available/slm-copilot.conf"
readonly NGINX_CERT_DIR="/etc/ssl/slm-copilot"
readonly NGINX_HTPASSWD="/etc/nginx/.htpasswd"
```
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Run `grep 'apt-get install.*nginx.*apache2-utils.*certbot' appliances/slm-copilot/appliance.sh` -- must match.
Run `grep 'rm -f.*sites-enabled/default' appliances/slm-copilot/appliance.sh` -- must match.
Run `grep 'NGINX_CONF\|NGINX_CERT_DIR\|NGINX_HTPASSWD' appliances/slm-copilot/appliance.sh` -- must find all 3 constants.
  </verify>
  <done>service_install installs nginx, apache2-utils, and certbot. Default nginx site removed. ACME challenge directory created. Three new constants defined for nginx config paths.</done>
</task>

<task type="auto">
  <name>Task 2: Add Phase 2 context variables to ONE_SERVICE_PARAMS and defaults</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Extend the ONE_SERVICE_PARAMS array and default value assignments with the two new Phase 2 context variables.

**Add to ONE_SERVICE_PARAMS array** (after the existing Phase 1 entries):

```bash
    # Phase 2: Security & Access
    'ONEAPP_COPILOT_PASSWORD'      'configure' 'API password (auto-generated if empty)'      ''
    'ONEAPP_COPILOT_DOMAIN'        'configure' 'FQDN for Let'\''s Encrypt certificate'       ''
```

**Add to default value assignments section** (after the existing Phase 1 defaults):

```bash
ONEAPP_COPILOT_PASSWORD="${ONEAPP_COPILOT_PASSWORD:-}"
ONEAPP_COPILOT_DOMAIN="${ONEAPP_COPILOT_DOMAIN:-}"
```

**Important:** The single quote in `Let's` inside the ONE_SERVICE_PARAMS single-quoted string must be escaped as `'\''` (end quote, escaped quote, start quote). This is standard POSIX shell quoting.
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Run `grep 'ONEAPP_COPILOT_PASSWORD' appliances/slm-copilot/appliance.sh` -- must appear in params and defaults.
Run `grep 'ONEAPP_COPILOT_DOMAIN' appliances/slm-copilot/appliance.sh` -- must appear in params and defaults.
  </verify>
  <done>ONE_SERVICE_PARAMS includes ONEAPP_COPILOT_PASSWORD and ONEAPP_COPILOT_DOMAIN with correct default values and lifecycle step. Default assignments use :- empty string fallback.</done>
</task>

<task type="auto">
  <name>Task 3: Implement generate_selfsigned_cert, generate_htpasswd, and generate_nginx_config helpers</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Add three new helper functions in the HELPER section of appliance.sh (after the existing helpers).

**Helper 1: generate_selfsigned_cert()**
Generates a self-signed X.509 certificate with the VM's IP address as a SAN. Uses symlink indirection so Let's Encrypt can swap certs without touching nginx config.

```bash
generate_selfsigned_cert() {
    local _vm_ip
    _vm_ip=$(hostname -I | awk '{print $1}')

    mkdir -p "${NGINX_CERT_DIR}"

    openssl req -x509 -nodes -newkey rsa:2048 \
        -keyout "${NGINX_CERT_DIR}/selfsigned-key.pem" \
        -out "${NGINX_CERT_DIR}/selfsigned-cert.pem" \
        -days 3650 \
        -subj "/CN=SLM-Copilot" \
        -addext "subjectAltName=DNS:localhost,IP:127.0.0.1,IP:${_vm_ip}"

    chmod 0600 "${NGINX_CERT_DIR}/selfsigned-key.pem"
    chmod 0644 "${NGINX_CERT_DIR}/selfsigned-cert.pem"

    # Active cert symlinks (Let's Encrypt replaces these in plan 02-02)
    ln -sf "${NGINX_CERT_DIR}/selfsigned-cert.pem" "${NGINX_CERT_DIR}/cert.pem"
    ln -sf "${NGINX_CERT_DIR}/selfsigned-key.pem" "${NGINX_CERT_DIR}/key.pem"

    msg info "Self-signed certificate generated for ${_vm_ip}"
}
```

**Key decisions:**
- RSA 2048-bit (ephemeral self-signed, regenerated every boot)
- 3650-day expiry (avoid mid-deployment warnings)
- SAN includes VM IP so `curl -k https://<vm-ip>/` works
- Symlink indirection (`cert.pem` -> `selfsigned-cert.pem`) enables Let's Encrypt swap

**Helper 2: generate_htpasswd()**
Generates the htpasswd file for Nginx basic auth. Auto-generates a random 16-char password if not provided.

```bash
generate_htpasswd() {
    local _password="${ONEAPP_COPILOT_PASSWORD:-}"

    if [ -z "${_password}" ]; then
        _password=$(tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 16)
        msg info "Auto-generated API password (no ONEAPP_COPILOT_PASSWORD set)"
    fi

    htpasswd -cbB "${NGINX_HTPASSWD}" copilot "${_password}"
    chmod 0640 "${NGINX_HTPASSWD}"

    # Persist password for report file (Phase 3)
    mkdir -p /var/lib/slm-copilot
    echo "${_password}" > /var/lib/slm-copilot/password
    chmod 0600 /var/lib/slm-copilot/password

    msg info "htpasswd written to ${NGINX_HTPASSWD} (user: copilot)"
}
```

**Key decisions:**
- Username is always `copilot` (single-user appliance)
- `-B` for bcrypt (strongest available)
- `-c` overwrites file (idempotent on reboot)
- Password stored in root-only file for Phase 3 report

**Helper 3: generate_nginx_config()**
Generates the complete Nginx configuration as a single file covering all requirements.

```bash
generate_nginx_config() {
    cat > "${NGINX_CONF}" <<'NGINX_EOF'
# /etc/nginx/sites-available/slm-copilot.conf
# Generated by SLM-Copilot appliance

# --- HTTP server (port 80): redirect to HTTPS + ACME challenge ---
server {
    listen 80 default_server;
    server_name _;

    # Let's Encrypt HTTP-01 challenge
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/acme-challenge;
    }

    # Redirect everything else to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

# --- HTTPS server (port 443): TLS + auth + proxy ---
server {
    listen 443 ssl default_server;
    server_name _;

    # TLS configuration
    ssl_certificate     /etc/ssl/slm-copilot/cert.pem;
    ssl_certificate_key /etc/ssl/slm-copilot/key.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ssl_buffer_size     4k;

    # CORS headers on ALL responses (including errors)
    add_header Access-Control-Allow-Origin "*" always;
    add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;

    # --- Health check endpoints (no auth) ---
    location = /readyz {
        auth_basic off;
        proxy_pass http://127.0.0.1:8080/readyz;
    }

    location = /health {
        auth_basic off;
        return 200 'ok\n';
        add_header Content-Type text/plain always;
    }

    # --- Main API proxy ---
    location / {
        # Handle OPTIONS preflight (no auth, no proxy)
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin "*" always;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
            add_header Access-Control-Max-Age 86400 always;
            add_header Content-Length 0 always;
            return 204;
        }

        # Basic authentication
        auth_basic "SLM-Copilot API";
        auth_basic_user_file /etc/nginx/.htpasswd;

        # Reverse proxy to LocalAI
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # SSE streaming (ALL required -- see 02-RESEARCH.md Pattern 4)
        proxy_buffering off;
        proxy_cache off;
        proxy_set_header Connection '';
        proxy_set_header X-Accel-Buffering no;
        chunked_transfer_encoding off;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;

        # Disable gzip for SSE (prevents buffering)
        gzip off;
    }
}
NGINX_EOF

    # Create symlink in sites-enabled
    ln -sf "${NGINX_CONF}" /etc/nginx/sites-enabled/slm-copilot.conf

    # Validate config before proceeding
    if ! nginx -t 2>&1; then
        msg error "Nginx configuration validation failed -- check ${NGINX_CONF}"
        exit 1
    fi

    msg info "Nginx config written to ${NGINX_CONF}"
}
```

**Critical implementation notes:**
- Uses `<<'NGINX_EOF'` (single-quoted heredoc delimiter) so that `$host`, `$request_method`, `$remote_addr`, `$proxy_add_x_forwarded_for`, `$scheme`, and `$request_uri` are written LITERALLY as nginx variables and not expanded by bash.
- CORS headers duplicate inside the `if` block because nginx's `add_header` does NOT inherit into `if` blocks.
- The `always` modifier is on EVERY `add_header` to ensure CORS headers appear on 401/500 error responses.
- `ssl_buffer_size 4k` reduces TLS buffer for better SSE streaming latency.
- `gzip off` in the location block prevents gzip from buffering SSE output.
- `proxy_read_timeout 600s` allows 10-minute CPU inference (3-5 tok/s * 2000 tokens).
- `nginx -t` validates the config; exits on failure before nginx starts.
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Run `grep -c 'generate_selfsigned_cert\|generate_htpasswd\|generate_nginx_config' appliances/slm-copilot/appliance.sh` -- must be >= 6 (3 definitions + 3 calls).
Run `grep 'openssl req.*-x509' appliances/slm-copilot/appliance.sh` -- must match cert generation.
Run `grep 'htpasswd.*-cbB' appliances/slm-copilot/appliance.sh` -- must match password generation.
Run `grep 'proxy_buffering off' appliances/slm-copilot/appliance.sh` -- must match SSE config.
Run `grep 'ssl_buffer_size' appliances/slm-copilot/appliance.sh` -- must match TLS buffer config.
Run `grep 'nginx -t' appliances/slm-copilot/appliance.sh` -- must match config validation.
Run `grep "NGINX_EOF" appliances/slm-copilot/appliance.sh` -- must match heredoc delimiters.
  </verify>
  <done>Three helper functions implemented: generate_selfsigned_cert (RSA 2048, VM IP SAN, symlink indirection), generate_htpasswd (bcrypt, auto-generation, password persistence), generate_nginx_config (complete single-file config with TLS, auth, CORS, OPTIONS bypass, SSE streaming, health bypass, HTTP redirect, gzip off, nginx -t validation).</done>
</task>

<task type="auto">
  <name>Task 4: Wire Nginx into service_configure and service_bootstrap lifecycle stages</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Extend service_configure() and service_bootstrap() to call the new Phase 2 helpers.

**In service_configure(), add AFTER the existing `systemctl daemon-reload` (step 7) and BEFORE the completion message:**

The ordering within service_configure is critical. The calls must be:
1. validate_config (existing -- already first)
2. ... existing Phase 1 steps ...
3. generate_selfsigned_cert (certs MUST exist before nginx config)
4. generate_htpasswd (htpasswd MUST exist before nginx config)
5. generate_nginx_config (references cert and htpasswd paths)

Add these three calls after the existing `systemctl daemon-reload` line:

```bash
    # Phase 2: Nginx reverse proxy with TLS and auth
    # Order matters: certs and htpasswd MUST exist before nginx config is written
    generate_selfsigned_cert
    generate_htpasswd
    generate_nginx_config
```

**In service_bootstrap(), add AFTER the existing `wait_for_localai` call and BEFORE the completion message:**

```bash
    # Phase 2: Start Nginx reverse proxy
    systemctl enable nginx
    systemctl restart nginx
```

Use `restart` (not `start`) because nginx may already be running from a previous boot cycle. `restart` is idempotent and picks up config changes.

**Update the completion message** in service_bootstrap to reflect both services:
Change `msg info "SLM-Copilot bootstrap complete -- LocalAI serving on 127.0.0.1:8080"`
to `msg info "SLM-Copilot bootstrap complete -- LocalAI on 127.0.0.1:8080, Nginx on 0.0.0.0:443"`

**Update service_help()** to include the Phase 2 information:
- Add ONEAPP_COPILOT_PASSWORD and ONEAPP_COPILOT_DOMAIN variables
- Add ports 80 (HTTP redirect) and 443 (HTTPS API)
- Add Nginx service management commands
- Add Nginx configuration file locations
- Update the test command to use HTTPS with basic auth
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Run `grep -A3 'generate_selfsigned_cert' appliances/slm-copilot/appliance.sh` -- must appear in service_configure.
Run `grep -A3 'generate_htpasswd' appliances/slm-copilot/appliance.sh` -- must appear in service_configure.
Run `grep -A3 'generate_nginx_config' appliances/slm-copilot/appliance.sh` -- must appear in service_configure.
Run `grep 'systemctl.*nginx' appliances/slm-copilot/appliance.sh` -- must appear in service_bootstrap.
Verify ordering: generate_selfsigned_cert appears before generate_nginx_config in service_configure.
Verify ordering: generate_htpasswd appears before generate_nginx_config in service_configure.
Verify ordering: wait_for_localai appears before systemctl restart nginx in service_bootstrap.
  </verify>
  <done>service_configure calls generate_selfsigned_cert, generate_htpasswd, generate_nginx_config in correct order (certs and htpasswd before config). service_bootstrap starts nginx after LocalAI is ready. service_help updated with Phase 2 information.</done>
</task>

<task type="auto">
  <name>Task 5: Update validate_config with Phase 2 context variable validation</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Extend the existing validate_config() function to validate the two new Phase 2 context variables.

**Add AFTER the existing ONEAPP_COPILOT_THREADS validation block, BEFORE the abort check:**

```bash
    # ONEAPP_COPILOT_DOMAIN: if set, must look like a valid FQDN (contains dot, no spaces)
    if [ -n "${ONEAPP_COPILOT_DOMAIN}" ]; then
        if [[ "${ONEAPP_COPILOT_DOMAIN}" =~ [[:space:]] ]] || \
           [[ ! "${ONEAPP_COPILOT_DOMAIN}" =~ \. ]]; then
            msg error "ONEAPP_COPILOT_DOMAIN='${ONEAPP_COPILOT_DOMAIN}' -- must be a valid FQDN (e.g., copilot.example.com)"
            _errors=$((_errors + 1))
        fi
    fi
```

**Notes:**
- ONEAPP_COPILOT_PASSWORD does not need validation -- any non-empty string is valid, and empty triggers auto-generation.
- ONEAPP_COPILOT_DOMAIN validation is only applied when the variable is set (non-empty). If empty, Let's Encrypt is simply skipped.
- The FQDN check is deliberately simple: must contain at least one dot and no whitespace. We don't need RFC-strict validation -- certbot will provide the definitive validation.

**Update the validation passed message** to include the new variables:
```bash
    msg info "Configuration validation passed (context_size=${ONEAPP_COPILOT_CONTEXT_SIZE}, threads=${ONEAPP_COPILOT_THREADS}, domain=${ONEAPP_COPILOT_DOMAIN:-none})"
```
  </action>
  <verify>
Run `bash -n appliances/slm-copilot/appliance.sh` to verify syntax.
Run `grep 'ONEAPP_COPILOT_DOMAIN' appliances/slm-copilot/appliance.sh` -- must appear in validate_config.
Run `grep 'domain=' appliances/slm-copilot/appliance.sh` -- must appear in validation passed message.
  </verify>
  <done>validate_config validates ONEAPP_COPILOT_DOMAIN (FQDN format check when non-empty). Password has no validation (any string valid, empty triggers auto-generation). Validation message includes domain status.</done>
</task>

<task type="auto">
  <name>Task 6: Shellcheck compliance and final verification</name>
  <files>appliances/slm-copilot/appliance.sh</files>
  <action>
Run shellcheck on the updated appliance.sh and fix all warnings/errors.

**Step 1: Run shellcheck**
```bash
shellcheck -s bash appliances/slm-copilot/appliance.sh
```

**Common issues to fix proactively in the new code:**
- SC2086: Double-quote variable expansions (especially in `hostname -I | awk`)
- SC2155: Declare and assign separately for local variables capturing command output
- Ensure the `<<'NGINX_EOF'` heredoc doesn't trigger any shellcheck warnings

**Step 2: Verify complete file structure** follows this order:
1. Shebang + header comment
2. Shellcheck directives (SC2034)
3. ONE_SERVICE_* metadata
4. ONE_SERVICE_PARAMS (Phase 1 + Phase 2 entries)
5. Default value assignments (Phase 1 + Phase 2)
6. Constants (Phase 1 + Phase 2: NGINX_CONF, NGINX_CERT_DIR, NGINX_HTPASSWD)
7. service_install() (Phase 1 + Phase 2 additions)
8. service_configure() (Phase 1 + Phase 2 additions)
9. service_bootstrap() (Phase 1 + Phase 2 additions)
10. service_cleanup()
11. service_help() (updated)
12. Helper functions (existing Phase 1 + new Phase 2: generate_selfsigned_cert, generate_htpasswd, generate_nginx_config)

**Step 3: Verify no append patterns**
Search for `>>` -- should be 0 (all config uses `>` overwrite).

**Step 4: Verify correct ordering in service_configure:**
1. validate_config
2. mkdir -p (directories)
3. AVX2 check
4. generate_model_yaml
5. generate_env_file
6. generate_systemd_unit
7. systemctl daemon-reload
8. generate_selfsigned_cert
9. generate_htpasswd
10. generate_nginx_config

**Step 5: Verify correct ordering in service_bootstrap:**
1. systemctl enable + start local-ai
2. wait_for_localai
3. systemctl enable + restart nginx

**Step 6: Count all functions** -- should be 14 total:
5 lifecycle (service_install, service_configure, service_bootstrap, service_cleanup, service_help)
+ 9 helpers (validate_config, generate_model_yaml, generate_env_file, generate_systemd_unit, wait_for_localai, smoke_test, generate_selfsigned_cert, generate_htpasswd, generate_nginx_config)
  </action>
  <verify>
Run `shellcheck -s bash appliances/slm-copilot/appliance.sh` -- must exit 0.
Run `bash -n appliances/slm-copilot/appliance.sh` -- must exit 0.
Run `wc -l appliances/slm-copilot/appliance.sh` -- should be 550+ lines.
Run `grep -c '>>' appliances/slm-copilot/appliance.sh` -- should be 0.
Run `grep -cE '^[a-z_]+\(\)' appliances/slm-copilot/appliance.sh` -- should be 14 functions.
  </verify>
  <done>appliance.sh passes shellcheck and bash -n with zero warnings. File structure follows one-apps conventions. No append patterns. All 14 functions properly defined. SEC-01, SEC-02, SEC-03, SEC-04, SEC-05, SEC-08, SEC-09 addressed.</done>
</task>

</tasks>

<verification>
- `shellcheck -s bash appliances/slm-copilot/appliance.sh` exits 0
- `bash -n appliances/slm-copilot/appliance.sh` exits 0
- service_install: installs nginx, apache2-utils, certbot; removes default site; creates ACME dir
- service_configure: generates self-signed cert (before nginx config), htpasswd (before nginx config), complete nginx config (TLS + auth + CORS + OPTIONS + SSE + health + redirect), validates with nginx -t
- service_bootstrap: starts nginx after LocalAI is ready
- ONE_SERVICE_PARAMS includes ONEAPP_COPILOT_PASSWORD and ONEAPP_COPILOT_DOMAIN
- validate_config validates ONEAPP_COPILOT_DOMAIN format
- No `>>` append patterns
- All helpers use constants (NGINX_CONF, NGINX_CERT_DIR, NGINX_HTPASSWD)
- CORS headers have `always` modifier on all `add_header` directives
- OPTIONS returns 204 without auth (if block with return 204)
- SSE has all 6 anti-buffering directives + gzip off
- HTTP redirect: port 80 returns 301 to https, except ACME challenge
- Self-signed cert uses symlink indirection for Let's Encrypt swap (plan 02-02)
</verification>

<success_criteria>
The appliance.sh has a complete Nginx reverse proxy integrated across all lifecycle stages. A Packer build using this script would produce an image where the VM boots, generates a self-signed TLS certificate and htpasswd file, writes the nginx config, starts both LocalAI and Nginx, and serves the OpenAI-compatible API over HTTPS with basic auth, CORS headers, SSE streaming, and HTTP-to-HTTPS redirect. Plan 02-02 will add Let's Encrypt automation on top of this foundation.
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-access/02-01-SUMMARY.md`
</output>
